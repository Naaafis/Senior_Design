const config = require('./config');
if (config.SockJS) {
  // dont use configurify for exporting sockjs
  config.SockJS = require('sockjs-client');
}
if (config.WS) {
  // dont use configurify for exporting ws
  config.WS = require('ws');
}
const Promise = require('lie');
const Events = require('backbone-events-standalone');
const Room = require('./room.js');
const assign = require('lodash.assign');
const get = require('lodash.get');
const omit = require('lodash.omit');
const sockEvents = require('./sock_events.js');
const {
  isString, isFunction, wrapError, hasListeners, warn
} = require('./utils');
const States = {
  CLOSED: 0,
  OPEN: 1,
  HANDSHAKEN: 2,
  AUTHENTICATED: 3
};
const ABNORMAL_CLOSURE = 1006;
const {isNode, isBrowser, isBrowserLite, isReactNative} = config;
let reconnectAttempt = 0;

function Scaledrone(channel, options) {
  if (!channel) {
    throw new Error('No Channel ID is defined');
  }
  if (!isString(channel)) {
    throw new Error('Channel ID must be of type string');
  }
  options = assign({}, {
    autoReconnect: true,
    url: null,
    originalInstance: this,
    data: null,
    debug: false,
  }, options);
  this.args = arguments;
  this.args[1] = options;
  this.originalInstance = options.originalInstance;
  this.readyState = States.CLOSED;
  this.callbackId = 0;
  this.callbacks = {};
  this.rooms = {};
  this.disconnected = false;
  this.connection = getConnection(options);
  this.emitter = Events.mixin({});
  sockEvents(this.connection, this.emitter, {debug: options.debug});
  this.autoReconnect = options.autoReconnect;
  this.innerEmitter = Events.mixin({});
  this.eventPromises = this.createEventPromises();

  this.emitter.on('open', () => {
    this.readyState = States.OPEN;
    this._sendMessage('handshake', {
      channel,
      version: 2,
      client_data: options.data,
    }, {}, (error, data) => {
      if (!error) {
        this.clientId = data.client_id;
        this.readyState = States.HANDSHAKEN;
        this.requireAuth = data.require_auth;
      }
      this._trigger('open', error);
    });
  });

  this.emitter.on('message', event => {
    const data = JSON.parse(event.data);
    const safeData = omit(data, ['callback', 'error']);

    const observableMessageTypes = [
      'observable_members',
      'observable_member_join',
      'observable_member_leave',
    ];

    // observable event
    if (observableMessageTypes.indexOf(data.type) !== -1) {
      const room = this.rooms[data.room];
      if (!room) {
        return;
      }
      const eventName = data.type.slice('observable_'.length);
      room.trigger(eventName, data.data);
      return;
    }

    // callback
    if (data.callback != null) {
      const cid = data.callback,
      callback = this.callbacks[cid];
      if (isFunction(callback)) {
        callback(wrapError(data.error), safeData);
        delete this.callbacks[cid];
        return;
      }
    }

    // error
    if (data.error) {
      this.trigger('error', wrapError(data.error));
      return;
    }

    // message / publish
    if (data.type === 'publish') {
      const room = this.rooms[data.room];
      if (!room) {
        return;
      }
      const message = {
        data: data.message,
        id: data.id,
        timestamp: data.timestamp,
      };
      const {client_id} = data;
      if (data.client_id) {
        message.clientId = client_id;
      }
      let member;
      if (room._observable && client_id) {
        member = room._getCacheMember(client_id);
        message.member = member;
      }
      room.trigger('message', message);
      room.trigger('data', data.message, member); // deprecated 'data' event
      return;
    }

    // history message
    if (data.type === 'history_message') {
      const room = this.rooms[data.room];
      if (!room) {
        return;
      }
      room._handleHistoryMessage(data);
      return;
    }
  });

  this.emitter.on('close', event => {
    if (
      this.autoReconnect &&
      get(event, 'code') === ABNORMAL_CLOSURE &&
      get(event, 'reason', '').indexOf('exceeded') === -1
    ) {
      // check if client has already disconnected
      // has already tired to reconnect
      if (!this.disconnected) {
        this.trigger('disconnect');
      }
      reconnect(this, options, event);
    } else {
      this.trigger('close', event);
    }
  });

  this.emitter.on('error', error => this.trigger('error', error));

  this.emitter.on('disconnect', () => this.disconnected = true);
  this.emitter.on('reconnect', () => this.disconnected = false);
  this.emitter.on('authenticate',
    error => this._trigger('authenticate', error)
  );
}

Events.mixin(Scaledrone.prototype);

Scaledrone.prototype._trigger = function(type, error) {
  if (hasListeners(this, type)) {
    this.trigger(type, error);
  } else if (error) {
    this.trigger('error', error);
  }
  this.innerEmitter.trigger(type, error);
};

Scaledrone.prototype._sendMessage = function(
  type, data, options = {}, callback
) {
  const message = assign({type}, data);
  if (callback) {
    const callbackID = this.callbackId++;
    message.callback = callbackID;
    this.callbacks[callbackID] = callback;
  }
  const promise = options.waitForPromise || Promise.resolve();
  promise.then(() => this.connection.send(JSON.stringify(message)));
};

Scaledrone.prototype.subscribe = function(roomName, {historyCount} = {}) {
  if (!roomName) {
    throw new Error('Room name is not defined');
  }
  if (!isString(roomName)) {
    throw new Error('Room name must be of type string');
  }
  const room = new Room(roomName, {historyCount}, this);
  this.rooms[roomName] = room;
  this._sendMessage('subscribe', {
    room: roomName,
    history: historyCount, //TODO: remove once all servers have depracated this param
    history_count: historyCount,
  }, {
    waitForPromise: this.eventPromises.fullyConnected
  }, error => room._trigger('open', error));
  return room;
};

Scaledrone.prototype.unsubscribe = function(roomName) {
  if (!roomName) {
    throw new Error('Room name is not defined');
  }
  if (!isString(roomName)) {
    throw new Error('Room name must be of type string');
  }
  this._sendMessage(
    'unsubscribe',
    {room: roomName},
    {waitForPromise: this.eventPromises.fullyConnected}
  );
};

Scaledrone.prototype.publish = function(options) {
  if (!options) {
    throw new Error('No options defined');
  }
  if (!options.room) {
    throw new Error('No room defined');
  }
  if (!options.message) {
    throw new Error('No message defined');
  }
  if (this.readyState === States.CLOSED) {
    throw new Error('Connection is closed');
  }
  let sendOptions = {waitForPromise: this.eventPromises.fullyConnected};
  if (this.requireAuth && this.readyState !== States.AUTHENTICATED) {
    warn('Messages can be sent after authenticating');
    sendOptions = {};
  }
  this._sendMessage(
    'publish', {room: options.room, message: options.message}, sendOptions
  );
};

Scaledrone.prototype.authenticate = function(token) {
  if (!token) {
    throw new Error('No token defined');
  }
  this._sendMessage(
    'authenticate',
    {token},
    {waitForPromise: this.eventPromises.open},
    error => {
      this.readyState = States.AUTHENTICATED;
      this.token = token;
      this.emitter.trigger('authenticate', error);
    }
  );
};

Scaledrone.prototype.close = function() {
  this.connection.close();
};

Scaledrone.prototype.createEventPromises = function() {
  return {
    fullyConnected: new Promise((resolve, reject) => {
      const listenToAuthenticate = () => {
        this.innerEmitter.once('authenticate', error => {
          if (error) {
            reject(error);
          } else {
            resolve();
          }
        });
      };
      this.innerEmitter.once('open', error => {
        if (error) {
          reject(error);
        } else {
          if (this.requireAuth) {
            listenToAuthenticate();
          } else {
            resolve();
          }
        }
      });
    }),
    open: new Promise((resolve, reject) => {
      this.innerEmitter.once('open', error => {
        if (error) {
          reject(error);
        } else {
          resolve();
        }
      });
    }),
  };
};

function reconnect(old, options, cause) {
  const originalInstance = old.originalInstance;
  if (reconnectAttempt > 25) {
    originalInstance.trigger('close', cause);
  } else {
    const timeout = reconnectAttempt++ * 1000 * (Math.random() + 0.5);
    setTimeout(function() {
      const args = originalInstance.args;
      const drone = new Scaledrone(args[0], args[1]);
      drone.innerEmitter.on('open', function() {
        reconnectAttempt = 0;
        drone.emitter = originalInstance.emitter;
        // Just in case give the old flag to the connection
        old.connection.old = true;
        // Replace the old connection so that
        // publish would be made to the new one
        originalInstance.connection = drone.connection;
        // Delegate new connection events to originalInstance emitter
        // that the client is listening to
        sockEvents(drone.connection, originalInstance.emitter);
        // Subscribe to originalInstance rooms
        for (const roomName in originalInstance.rooms) {
          drone.subscribe(roomName);
        }
        originalInstance.trigger('reconnect');
      });
    }, timeout);
  }
}

function getConnection(options) {
  if (options.type !== 'sockjs' && supportsWebsockets()) {
    if (isNode) {
      return new config.WS(
        options.url || config.websocketUrl, config.websocketOptions
      );
    } else {
      return new WebSocket(options.url || config.websocketUrl);
    }
  } else {
    return new config.SockJS(options.url || config.sockjsUrl, null, {
      transports: [
        'xdr', 'websocket-streaming', 'xhr-streaming',
        'iframe-eventsource', 'iframe-htmlfile', 'xdr-polling',
        'xhr-polling', 'iframe-xhr-polling', 'jsonp-polling'
      ]
    });
  }
}

function supportsWebsockets() {
  if (isBrowserLite) { // lite version only supports WS
    return true;
  }
  if (isNode && config.type !== 'sockjs') {
    return true;
  }
  if (isBrowser && 'WebSocket' in window && window.WebSocket.CLOSING === 2) {
    return true;
  }
  if (isReactNative) {
    return true;
  }
  return false;
}

if (isBrowser) {
  window.ScaleDrone = window.Scaledrone = Scaledrone;
} else {
  module.exports = Scaledrone;
}
