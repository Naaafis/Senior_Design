const Events = require('backbone-events-standalone');
const {hasListeners} = require('./utils');

function Room(name, {historyCount}, scaledrone) {
  this.name = name;
  this._history = {
    messages: [],
    nextIndex: 0,
  };
  this._historyCount = historyCount;
  this.scaledrone = scaledrone;
  this._observable = isObservable(name);
  if (this._observable) {
    this._cache = [];
    this.on('members', members => this._cache = members.slice(0));
    this.on('member_join', member => this._cache.unshift(member));
  }
}

Events.mixin(Room.prototype);

Room.prototype.unsubscribe = function() {
  this.off();
	this.scaledrone.unsubscribe(this.name);
};

Room.prototype._getCacheMember = function(id) {
  if (typeof id !== 'string') {
    return null;
  }
  for (let i = 0; i < this._cache.length; i++) {
    const member = this._cache[i];
    if (member.id === id) {
      return member;
    }
  }
  return null;
};

Room.prototype._trigger = function(type, error) {
  if (hasListeners(this, type)) {
    this.trigger(type, error);
  } else if (error) {
    this.scaledrone.trigger('error', error);
  }
};

Room.prototype._handleHistoryMessage = function(data) {
  // Making sure the events get triggered in the right order
  const trigger = () => {
    const data = this._history.messages[this._history.nextIndex];
    this._history.nextIndex++;
    const {message, client_id, timestamp, id} = data;
    const historyMessage = {data: message, timestamp, id};
    if (client_id) {
      historyMessage.clientId = client_id;
    }
    this.trigger('history_message', historyMessage);
    if (this._history.messages[this._history.nextIndex]) {
      trigger();
    }
  };
  this._history.messages[data.index] = data;
  if (this._history.messages[this._history.nextIndex]) {
    trigger();
  }
};

module.exports = Room;

function isObservable(name) {
  return name && name.substring(0, 11) === "observable-";
}
